# 토비의 스프링 3.1 Vol.2 스프링의 기술과 선택

# 1장 IoC 컨테이너와 DI

## 1.1 IoC 컨테이너: 빈 팩토리와 애플리케이션 컨텍스트

### 1.1.1 IoC 컨테이너를 이용해 애플리케이션 만들기

- 스프링 IoC 컨테이너는 빈 설정 메타정보를 이용해 빈 오브젝트를 만들고 DI 작업을 수행

- 스프링의 설정 메타정보는 `BeanDefinition` 인터페이스로 표현되는 순수한 추상 정보다. (p55)

### 1.1.2 IoC 컨테이너의 종류와 사용 방법

**StaticApplicationContext**

- 스태틱 애플리케이션 컨텍스트는 실전에서는 사용하면 안됨, 테스트 목적

**GenericApplicationContext**

- 가장 일반적인 애플리케이션 컨텍스트의 구현 클래스
- StaticApplicationContext와는 달리 XML 파일과 같은 외부의 리소스에 있는 빈 설정 메타정보를 리더를 통해 읽어들여서 메타정보로 전환해서 사용

**GenericXmlApplicationContext**

- XmlBeanDefinitionReader를 내장

**WebApplicationContext**

- 웹 애플리케이션에서 스프링 애플리케이션을 기동시키는 방법은 무엇일까?
  - 일단 main() 메소드 역할을 하는 서블릿을 만들어두고, 미리 애플리케이션 컨텍스트를 생성해둔 다음, 요청이 서블릿으로 들어올 때마다 getBean()으로 필요한 빈을 가져와 정해진 메소드를 실행해주면 된다.
- DispatcherServlet : 웹 환경에서 애플리케이션 컨텍스트를 생성하고 설정 메타정보로 초기화해주고, 클라이언트로부터 들어오는 요청마다 적절한 빈을 찾아서 이를 실행해주는 기능을 수행

- WebApplicationContext의 특징은 자신이 만들어지고 동작하는 환경인 웹 모듈에 대한 정보에 접근할 수 있다는 점 

- 이를 이용해 웹 환경으로부터 필요한 정보를 가져오거나, 웹 환경에 스프링 컨테이너 자신을 노출할 수 있다. 

- 컨테이너가 웹 환경에 노출되면 같은 웹 모듈에 들어 있는 스프링 빈이 아닌 일반 오브젝트와 연동될 수 있다.

### 1.1.3 IoC 컨테이너 계층구조

### 1.1.4 웹 애플리케이션의 IoC 컨테이너 구성

- 프론트 컨트롤러 패턴 (p72)

**서블릿 애플리케이션 컨텍스트 등록**

- 각 DispatcherServlet은 서블릿이 초기화될 때 자신만의 컨텍스트를 생성하고 초기화한다. 동시에 웹 애플리케이션 레벨에 등록
  된 루트 애플리케이션 컨텍스트를 찾아서 이를 자신의 부모 컨텍스트로 사용한다.

## 1.2 IoC/DI를 위한 빈 설정 메타정보 작성

### 1.2.1 빈 설정 메타정보

### 1.2.2 빈 등록 방법

- 스프링에서 자주 사용되는 빈의 등록 방법은 크게 다섯 가지가 있다.

**1. XML: <bean> 태그**

**2. XML: 네임스페이스와 전용 태그**

**3. 자동인식을 이용한 빈 등록: 스테레오타입 애노테이션과 빈 스캐너**

- `AnnotationConfigApplicationContext`  : 빈 스캐너를 내장하고 있는 애플리케이션 컨텍스트 구현 클래스

- 커스텀 스테레오타입 애노테이션

  ```java
  @Target({ElementType.TYPE})
  @Retention(RetentionPolicy.RUNTIME)
  @Documented
  @Component // @Component를 메타 애노테이션으로 선언해주면 빈 스캐너 디폴트 필터의 자동인식 대상이 된다.
  public @interface BusinessRule {
  
  	String value() default ""; // 빈의 아이디를 직접 지정할 수 있도록 디폴트 엘리먼트를 선언해둔다.
  }
  ```

**4. 자바 코드에 의한 빈 등록: @Configuration 클래스의 @Bean 메소드**

- 스프링은 @Bean이 붙은 메소드를 이용해서 빈을 만들 때, 싱글톤 빈이라면 한 개의 오브젝트만 생성이 되고 더 이상 새로운 오브젝트가 만들어지지 않도록 특별한 방법으로 @Bean 메소드를 조작해둔다.
- 자바 코드를 이용한 빈 등록은 단순한 빈 스캐닝을 통한 자동인식으로는 등록하기 힘든 기술 서비스 빈의 등록이나 컨테이너 설정용 빈을 XML 없이 등록하려고 할 때 유용하게 쓸 수 있다.

- 자바 코드에 의한 설정이 XML과 같은 외부 설정파일을 이용하는 것보다 유용한 점
  - 컴파일러나 IDE를 통한 타입 검증이 가능하다.
  - 자동완성과 같은 IDE 지원 기능을 최대한 이용할 수 있다.
  - 이해하기 쉽다.
  - 복잡한 빈 설정이나 초기화 작업을 손쉽게 적용할 수 있다.

**5. 자바 코드에 의한 빈 등록: 일반 빈 클래스의 @Bean 메소드**

- 일반 빈 클래스에 @Bean을 사용한 경우, DI 설정을 위해 다른 메소드를 직접 호출하면 매번 다른 오브젝트를 받게 된다.

**빈 등록 메타정보 구성 전략**

### 1.2.3 빈 의존관계 설정 방법

**1. XML: <property>, <constructor-arg>**

**2. XML: 자동와이어링**

**3. XML: 네임스페이스와 전용 태그**

**4. 애노테이션: @Resource**

**5. 애노테이션: @Autowired/@Inject**

- 수정자 메소드와 필드
  
- @Resource와 다른 점은 이름 대신 필드나 프로퍼티 타입을 이용해 후보 빈을 찾는다는 것이다.
  
- 생성자
  - @Autowired는 @Resource와 다르게 생성자에도 부여할 수 있다. 이때는 생성자의 모든 파라미터에 타입에 의한 자동와이어링이 적용된다.
  - @Autowired는 단 하나의 생성자에만 사용할 수 있다는 제한이 있다.

- 일반 메소드 (p124)
  
- 생성자 주입과 달리 일반 메소드는 오브젝트 생성 후에 차례로 호출이 가능하므로 여러 개를 만들어도 된다. 한 번에 여러 개의 오브젝트를 DI 할 수 있으므로 코드도 상대적으로 깔끔해진다. 수정자 메소드 주입과 생성자 주입의 장점을 모두 갖춘 방식이다.
  
- 컬렉션과 배열
  
- @Autowired를 이용하면 같은 타입의 빈이 하나 이상 존재할 때 그 빈들을 모두 DI 받도록 할 수 있다. @Autowired의 대상이 되는 필드나 프로퍼티, 메소드의 파라미터를 컬렉션이나 배열로 선언하면 된다
  
- @Qualifier

  ```java
  @Autowired
  @Qualifier("mainDB")
  DataSource dataSource;
  
  ...
      
  @Component
  @Qualifier("mainDB")
  public class OracleDataSource {
  ```

**@Autowired와 getBean( ), 스프링 테스트**

**자바 코드에 의한 의존관계 설정**

- @Configuration과 @Bean을 이용해서 자바 코드로 빈을 등록하는 경우에 빈의 의존관계를 설정하는 방법은 다음 3가지

**1. 애노테이션에 의한 설정 @Autowired, @Resource**

**2. @Bean 메소드 호출**

**3. @Bean과 메소드 자동와이어링**

### 1.2.4 프로퍼티 값 설정 방법

**메타정보 종류에 따른 값 설정 방법**

**1. XML: <property>와 전용 태그**

**2. 애노테이션: @Value**

**3. 자바 코드: @Value**

**PropertyEditor와 ConversionService**

**컬렉션**

**Null과 빈 문자열**

**프로퍼티 파일을 이용한 값 설정**

- 수동 변환: PropertyPlaceHolderConfigurer
- 능동 변환: SpEL
  - SpEL은 기본적으로 #{} 안에 표현식을 넣도록 되어 있다.

### 1.2.5 컨테이너가 자동등록하는 빈

**ApplicationContext, BeanFactory**

**ResourceLoader, ApplicationEventPublisher**

**systemProperties, systemEnvironment**

## 1.3 프로토타입과 스코프

- 스코프(scope)는 존재할 수 있는 범위를 가리키는 말

### 1.3.1 프로토타입 스코프

- 프로토타입 스코프는 컨테이너에게 빈을 요청할 때마다 매번 새로운 오브젝트를 생성해준다.

**프로토타입 빈의 생명주기와 종속성**

- 프로토타입 빈 오브젝트는 한번 DL이나 DI를 통해 컨테이너 밖으로 전달된 후에는 이 오브젝트는 더 이상 스프링이 관리하는 빈이 아니다.
- 프로토타입 빈은 이 빈을 주입받은 오브젝트에 종속적일 수밖에 없다.

**프로토타입 빈의 용도**

- 매번 새로운 오브젝트가 필요하면서 DI를 통해 다른 빈을 사용할 수 있어야 한다면 프로토타입 빈이 가장 적절한 선택이다.
- **@Scope("prototype")**

**DI와 DL**

- new 키워드를 대신하기 위해 사용되는 것이 프로토타입의 용도라고 본다면, DI는 프로토타입 빈을 사용하기에 적합한 방법이 아니다. 따라서 코드 내에서 필요할 때마다 컨테이너에게 요청해서 새로운 오브젝트를 만들어야 한다. (DL 방식)

**프로토타입 빈의 DL 전략**

- ApplicationContext, BeanFactory
- ObjectFactory, ObjectFactoryCreatingFactoryBean
- ServiceLocatorFactoryBean
- 메소드 주입
- Provider<T>

### 1.3.2 스코프

**요청 스코프**

**세션 스코프, 글로벌세션 스코프**

**애플리케이션 스코프**

- 애플리케이션 스코프는 서블릿 컨텍스트에 저장되는 빈 오브젝트다.
- 서블릿 컨텍스트는 웹 애플리케이션마다 만들어진다. 웹 애플리케이션마다 스프링의 애플리케이션 컨텍스트도 만들어진다. 따라서 애플리케이션 스코프는 컨텍스트가 존재하는 동안 유지되는 싱글톤 스코프와 비슷한 존재 범위를 갖는다.
- 그렇다면 싱글톤 스코프를 사용하면 될 텐데 애플리케이션 스코프가 따로 존재하는 이유는 무엇일까? 그것은 드물지만 웹 애플리케이션과 애플리케이션 컨텍스트의 존재 범위가 다른 경우가 있기 때문이다. 

**스코프 빈의 사용 방법**

- 스코프 빈은 프로토타입 빈과 마찬가지로 Provider나 ObjectFactory 같은 DL 방식으로 사용해야 한다.
- 직접 스코프 빈을 DI 하는 대신 스코프 빈에 대한 프록시를 DI 해줄 수 있다.

```java
@Scope(value="session", proxyMode=ScopedProxyMode.TARGET_CLASS)
public class LoginUser {
```

**커스텀 스코프와 상태를 저장하는 빈 사용하기**
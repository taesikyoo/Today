# 메시지 큐를 이용한 비동기 요청 처리

- 요청을 처리하는 방법

  - 동기 : 클라이언트가 요청을 보내면 처리한 다음 응답이 오는 방식
  - 비동기 : 요청을 보낸 후 비즈니스 로직이 처리가 완료되지 않은 상태에서 다음 로직을 진행

- 비동기식 요청 처리

  - 요청만 보내놓고 응답이 오는 것과 상관없이 클라이언트 대기 없이 다음 로직을 수행

    ![image](https://user-images.githubusercontent.com/37072010/114038588-f664b200-98bc-11eb-91e1-ef9d47f29c95.png)

- 비동기식 패턴 구현에는 일반적으로 메시지 큐를 사용

  - 메시지 큐 = 들어온 요청을 쌓아놓는 임시 공간, 쌓여 있는 요청 메시지는 뒤에 이어지는 비즈니스 로직이 처리
  - e.g. JMS(Java Messaging Server), Rabbit MQ, Kafka(대용량 분산 큐)

## 에러 처리

- 비동기식 구현에서 가장 중요하게 고려해야할 사항은 전달된 요청 메시지가 잘 처리되었느냐
- 비즈니스 컴포넌트에서 메시지 처리 중 에러가 났을 때 해당 메시지를 에러큐라는 재처리용 큐로 전달, 4가지 정책이 존재

![image](https://user-images.githubusercontent.com/37072010/114038609-fa90cf80-98bc-11eb-960d-f885b22dedd2.png)

### 1. 재처리(Retry)

- 최대 재처리 횟수 지정
- 일정 시간이 기다렸다가 다시 처리 (장애 복구까지 대기)
- 기다리는 대기 시간은 재처리 횟수에 비례해서 늘려주면 좋음

### 2. 무시(Ignore)

- 메시지 유실이 허용되는 경우 e.g. 중요하지 않은 로그

### 3. 알림(Notify)

- 이메일, SMS 등으로 관리자에게 통보

### 4. 사람이 처리하도록 함(Human Interaction)

## 비동기 메시지 패턴

### 1. File & Forget 패턴

- 가장 일반적인 비동기 호출 패턴
- 클라이언트가 호출한 후 큐에 메시지가 제대로 들어갔으면 메시지의 처리 결과에 관계없이 응답을 기다리지 않고 바로 반환

![image](https://user-images.githubusercontent.com/37072010/114038651-0381a100-98bd-11eb-8cb9-98e675937960.png)

### 2. Publish & Subscribe 패턴

- 메시지 큐에 구독자(Subscriber)를 등록
- 클라이언트에서 보낸 하나의 메시지가 등록된 모든 구독자에게 전달되어 처리
- 1:N 관계의 비동기 처리를 구현하고자 할 때 사용

![image](https://user-images.githubusercontent.com/37072010/114038672-07adbe80-98bd-11eb-8a81-57ebc752515b.png)

### 3. Routing 패턴

- 큐에 저장된 메시지를 조건에 따라 특정 비스니스 컴포넌트로 라우팅하는 기능
- 특정 메시지는 조건에 따라서 특정 비즈니스 컴포넌트 한 개에만 전달

![image](https://user-images.githubusercontent.com/37072010/114038684-0a101880-98bd-11eb-8e28-239c87f647ae.png)

### 4. Call Back 패턴

- 비즈니스 컴포넌트에서 처리가 끝나면 서버는 다시 클라이언트에 처리가 끝났다는 응답과 함께 처리 결과(Response) 메시지를 콜백으로 보냄
- 이때 클라이언트가 응답 메시지가 올 때까지 기다리는 것이 아니고 비즈니스 로직을 수행하고 있기 때문에 서버가 응답 메시지를 보내면 이벤트 핸들러 방식에 의해서 응답 메시지를 처리하는 이벤트 핸들러를 호출하여 응답 메시지를 처리

![image](https://user-images.githubusercontent.com/37072010/114038698-0c727280-98bd-11eb-8e74-3bd5521bca8c.png)

- 응답 메시지를 받기 위해 부가 정보가 필요
  - 콜백 주소 : 서버가 메시지를 다 처리한 후에 클라이언트로 응답을 보낼 때 사용하는 클라이언트의 IP주소와 포트
  - Correlation ID : 어느 요청에 대한 응답 메시지인지 식별

## 메시지 큐 구성 시 고려해야 할 사항

### 1. 성능 및 페일 오버를 고려한 Persistence의 선택

- 메시지를 물리적으로 어디에 저장할 것인가
- 메모리
- 파일 → NFS (Network File System, 공유 파일 저장소), 성능 저하 우려
- RDBMS : 클러스터링 구성 시 페일 오버도 비교적 잘되고, 메시지에 대한 관리가 쉬움, 그러나 느림

### 2. 펜딩 메시지로 말미암은 Out of Memory

- 메모리 과다 사용으로 인한 에러에 주의
- 메모리에 메시지를 저장할 경우
- 펜딩 메시지(Pending Message) = 메시지를 메모리에서 꺼내가지 않을 때, 쌓여 있는 메시지

### 3. 트랜잭션 지원 기능

- 메시지를 큐에서 빼간 후에 처리하다가 에러가 났을 경우 이 메시지는 다시 큐에 복귀되거나 또는 에러 큐로 보내져야 함
- 분산 트랜잭션을 지원하는 메시지 큐 시스템 : DB와 큐의 트랜잭션을 하나로 묶어서 자동으로 이러한 작업을 처리
- 트랜잭션을 지원하지 않을 경우 : 에러가 발생하였을 때 개발자가 에러 큐로 메시지를 던지거나 또는 다시 큐에 넣는 작업을 해줘야 함

### 4. 클러스터링 기능

- 클러스터링 = 여러 개의 메시지 큐를 하나의 클러스터로 묶는 기능
- 장점
  - 클러스터링을 통해 특정 인스턴스 장애 시 다른 인스턴스들이 장애가 난 인스턴스의 메시지를 받아서 처리하는 페일 오버(Fail Over) 기능
  - 힌 데의 서버로 처리할 수 없는 양의 메시지를 여러 대의 서버에서 분산 처리

## Amazon SQS

- 마이크로 서비스, 분산 시스템 및 서버리스 애플리케이션을 쉽게 분리하고 확장할 수 있도록 지원하는 완전관리형 메시지 대기열 서비스
- 메시지 지향 미들웨어를 관리하고 운영하는 데 따른 복잡성과 오버헤드를 제거하고 개발자가 차별화 작업에 집중할 수 있도록 지원
- 메시지를 손실하거나 다른 서비스를 가동할 필요 없이 소프트웨어 구성 요소 간에 어떤 볼륨의 메시지든 전송, 저장 및 수신 가능

### **표준 대기열**

![](https://d1.awsstatic.com/AmazonSQS/sqs-what-is-sqs-standard-queue-diagram.29963b2823bc048492c7af2757535d500aa2c159.png)

- **무제한 처리량**: 표준 대기열은 API 작업당 거의 무제한의 초당 트랜잭션(TPS)을 지원합니다.
- **최소한 한 번 전달**: 메시지가 최소한 한 번 전달되고, 가끔 2개 이상의 메시지 복사본이 전달될 수 있습니다.
- **최선 노력 순서**: 가끔 메시지가 전송된 순서와 다르게 전달될 수 있습니다.
- 한 번 이상 잘못된 순서로 도착하는 메시지를 애플리케이션에서 다음과 같이 처리할 수 있다면 여러 시나리오에서 표준 메시지 대기열을 사용할 수 있습니다.
  - 실시간 사용자 요청을 집중적 백그라운드 작업과 분리: 사용자들이 미디어 크기를 조정하거나 인코딩하면서 미디어를 업로드할 수 있게 합니다.
  - 작업을 여러 작업자 노드에 할당: 많은 수의 신용 카드 인증 요청을 처리합니다.
  - 장래 처리를 위한 메시지 배치: 데이터베이스에 여러 항목이 추가되도록 예약합니다.

### **FIFO 대기열**

![sqs-what-is-sqs-fifo-queue-diagram](https://d1.awsstatic.com/AmazonSQS/sqs-what-is-sqs-fifo-queue-diagram.8f1c8d366f58845ce03bb2983c16349102cf1524.png)

- **높은 처리량**: 기본적으로 FIFO 대기열은 초당 최대 300개의 메시지(초당 300개의 전송, 수신 또는 삭제 작업)를 지원합니다. 작업당 최대 10개 메시지를 일괄 처리할 경우, FIFO 대기열은 초당 3000개의 메시지까지 지원할 수 있습니다. 한도 증가를 요청하려면 [지원 요청을 제출](https://console.aws.amazon.com/support/v1?#/case/create)하십시오.
- **정확히 한 번 처리**: 메시지가 한 번 전달되고 소비자가 이를 처리 및 삭제할 때까지 유지됩니다. 중복 메시지는 대기열에 올라가지 않습니다.
- **선입선출 전달**: 메시지가 전송되고 수신되는 순서가 엄격하게 지켜집니다(예: 선입선출).
- FIFO 대기열은 다음 예와 같이 작업 및 이벤트 순서가 중요하거나 중복 항목이 허용되지 않는 경우에 애플리케이션 간 메시징을 강화해 줍니다.
  - 사용자가 입력한 명령이 올바른 순서로 실행되도록 해야 하는 경우.
  - 가격 수정을 올바른 순서로 전송하여 제품 가격을 정확히 표시해야 하는 경우.
  - 계정에 등록하기 전에 학생이 과정에 등록되는 것을 방지해야 하는 경우.

### 기능

- **무제한 대기열 및 메시지:** 메시지 수가 무제한인 무제한 Amazon SQS 대기열을 리전에 생성합니다.
- **페이로드 크기:** 메시지 페이로드는 형식과 관계없이 최대 256KB의 텍스트를 포함할 수 있습니다. 페이로드 64KB '청크'당 1개의 요청으로 청구됩니다. 예를 들어, 256KB 페이로드를 사용하는 단일 API 호출은 4개의 요청으로 청구됩니다. 256KB보다 큰 메시지를 전송하려면 Amazon S3에 메시지 페이로드를 저장하는 [Java용 Amazon SQS 확장 클라이언트 라이브러리](https://github.com/awslabs/amazon-sqs-java-extended-client-lib)를 사용하십시오. 메시지 페이로드에 대한 참조는 SQS를 사용하여 전송됩니다.
- **배치(Batches):** 한 번에 최대 10개 또는 256KB 메시지를 배치로 전송, 수신 또는 삭제할 수 있습니다. 배치 요금은 단일 메시지와 같습니다. 따라서 배치를 사용하면 SQS 비용을 좀 더 절약할 수 있습니다.
- **[긴 폴링:](http://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-long-polling.html)** 관계없는 폴링을 줄여 가능한 한 빨리 새 메시지를 받으면서 비용을 최소화합니다. 대기열이 비어 있는 경우 긴 폴링 요청은 다음 메시지가 도착할 때까지 최대 20초를 대기합니다. 긴 폴링 요청은 정기적인 요청과 비용이 같습니다.
- **메시지를 최대 14일 동안 대기열에 유지합니다.**
- **메시지를 동시에 보내고 읽습니다.**
- **메시지 잠금**: 메시지가 수신되면 처리되는 동안 "잠금" 상태가 됩니다. 다른 컴퓨터에서 동시에 메시지를 처리하지 못하도록 하기 위함입니다. 메시지 처리에 실패하면 잠금이 해제되면서 메시지가 다시 처리 가능한 상태로 바뀝니다.
- **대기열 공유:** 개발자는 Amazon SQS 대기열을 익명으로 또는 특정 AWS 계정과 안전하게 공유할 수 있습니다. IP 주소와 특정 시간으로 대기열 공유를 제한할 수도 있습니다.
- **서버 측 암호화(SSE):** AWS Key Management Service(AWS KMS)에서 관리하는 키를 사용하여 Amazon SQS 대기열의 메시지 콘텐츠를 보호합니다. SSE는 Amazon SQS가 메시지를 수신하자마자 이를 암호화합니다. 메시지는 암호화된 형태로 저장되며 Amazon SQS 는 권한이 있는 사용자에게 전송할 때만 메시지를 복호화합니다.
- **배달 못한 편지 대기열(DLQ):** 소비자가 성공적으로 처리하지 못한 메시지를 배달 못한 편지 대기열을 사용하여 처리합니다. 메시지에 대한 최대 수신 개수가 초과하면 해당 메시지는 원래 대기열에 연결된 배달 못한 편지 대기열(DLQ)로 이동됩니다. 메시지 전달이 중단된 이유를 분석하고 이해하는 데 도움이 될 수 있는 DLQ에 대해 별도의 소비자 프로세스를 설정하십시오. DLQ는 원본 대기열(표준 또는 FIFO)과 같은 유형이어야 합니다.

### Amazon SQS를 다른 AWS 인프라 웹 서비스와 함께 사용

- Redshift, DynamoDB, RDS, EC2, ECS, Lambda 및 S3 등 다른 AWS 서비스와 함께 사용하면 분산 애플리케이션의 안정성과 확장성을 더욱 향상 가능
- **작업 대기열**: 동일한 양의 작업 일부를 동시에 처리하지 못할 수 있는 분산 애플리케이션의 구성 요소를 분리합니다.
- **버퍼 및 배치(Batch) 작업**: 아키텍처에 확장성과 안정성을 더하고, 메시지를 손실하거나 지연 시간을 늘리지 않고 일시적인 볼륨 스파이크를 원활하게 처리합니다.
- **요청 분산**: 요청을 전송하여 대화식 요청 경로에서 속도가 느린 작업을 제거합니다.
- **팬아웃**: [SQS를 Simple Notification Service(SNS)와 결합](http://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqssubscribe.html)하여 메시지의 동일한 사본을 여러 대기열에 병렬로 전송합니다.
- **우선순위**: 별도의 대기열을 사용하여 작업의 우선순위를 지정합니다.
- **확장성**: 메시지 대기열에서 프로세스를 분리하므로, 다른 프로세스를 추가하기만 하면 손쉽게 메시지 송신이나 수신 속도를 높일 수 있습니다.
- **복원력**: 시스템 일부에 장애가 발생하더라도 전체 시스템에는 영향을 주지 않습니다. 메시지 대기열에서 시스템의 구성 요소를 분리하므로 대기열에서 메시지를 읽어오는 프로세스가 실패한 경우에도, 시스템이 복구되면 처리되도록 메시지를 대기열에 추가할 수 있습니다.

## 참고

- <대용량 아키텍쳐와 성능 튜닝>, 조대협, 프리렉, p262~

- [Amazon SQS | 메시지 대기열 서비스 | AWS](https://aws.amazon.com/ko/sqs/)
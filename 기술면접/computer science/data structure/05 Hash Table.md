# 05 Hash Table

- 핵심 아이디어 : O(log N) 시간보다 빠른 연산을 위해, 키와 1차원 배열의 인덱스의 관계를 이용하여 키(항목)를 저장한다.
- 탐색, 삽입, 삭제 연산을 평균 O(1) 시간에 지원한다.

- 키를 배열의 인덱스로 그대로 사용하면 메모리 낭비가 심할 수 있다. => 키를 적절히 변환하여 배열의 인덱스로 사용해야 한다.
- **해싱**(Hashing) : 키를 간단한 함수를 사용해 변환한 값을 배열의 인덱스로 이용하여 항목에 저장하는 것
- **해시함수**(Hash Function) : 해싱에 사용되는 함수
- **해시값**(Hash Value) : = 해시주소, 해시함수가 계산한 값
- **해시테이블**(Hash Table) : 항목이 해시값에 따라 저장되는 배열
- 서로 다른 키들이 동일한 해시값을 가질 때 충돌(Collisoin)이 발생했다고 한다.

## 해시함수

- 가장 이상적인 해시함수?
  - 키들을 균등하게(Uniformly) 해시테이블의 인덱스로 변환하는 함수
  - 균등하다 = 키들을 해시테이블에 랜덤하게 흩어지도록 저장하는 것
  - 즉 키들의 충돌을 최소화해야 한다.
- e.g. 키를 소수로 나눈 뒤 나머지를 해시값을 사용하는 나눗셈 함수

## 개방주소방식

개발주소방식(Open Addressing)은 해시테이블 전체를 열린 공간으로 가정하고 충돌된 키를 일정한 방식에 따라서 찾아낸 empty 원소에 저장한다.

### 1. 선형조사

- 선형 탐사(Linear Probing)

- 최초 해시값에 해당하는 버킷에 다른 데이터가 저장돼 있으면 해당 해시값에서 고정 폭(예컨대 1칸)을 옮겨 다음 해시값에 해당하는 버킷에 액세스(삽입, 삭제, 탐색)한다.

### 2. 이차조사

- 제곱 탐사(Quadratic probing)
- 고정 폭으로 이동하는 선형 탐사와 달리 그 폭이 제곱수로 늘어난다.
- e.g. 임의의 키값에 해당하는 데이터에 액세스할 때 충돌이 일어나면 1^2칸을 옮긴다. 여기에서도 충돌이 일어나면 이번엔 2^2칸, 그 다음엔 3^2칸 옮기는 식이다.

### 3. 랜덤조사

- 선형조사와 이차조사의 규칙적인 점프 시퀀스와는 달리 점프 시퀀스를 무작위화아여 empty 원소를 찾는 충돌해결방법

### 4. 이중해싱

- 탐사할 해시값의 규칙성을 없애서 clustering을 방지하는 기법
- 2개의 해시함수를 준비해서 하나는 최초의 해시값을 얻을 때, 또 다른 하나는 해시충돌이 일어났을 때 탐사 이동폭을 얻기 위해 사용
- 최초 해시값이 같더라도 탐사 이동폭이 달라지고, 탐사 이동폭이 같더라도 최초 해시값이 달라져 primary, secondary clustering을 모두 완화할 수 있음

## 폐쇄주소방식

폐쇄주소방식(Closed Addressing)의 충돌해결 방법은 키에 대한 해시값에 대응되는 곳에만 키를 저장한다. 따라서 충돌이 발생한 키들은 한 위치에 모여 저장된다.

### 체이닝(Chaining)

![](https://user-images.githubusercontent.com/33534771/74128107-bdc93a00-4c1f-11ea-9cfb-32f0035eee33.png)

- Key에 대한 index가 가리키는 자료구조를 LinkedList를 이용하는 방식이다.
- index로 인해서 충돌이 발생하면 그 index가 가리키고 있는 LinkedList에 노드를 추가한다.
- 데이터를 검색할 때, 선형 탐색을 하기 때문에 느리다는 단점이 있다.
  - 시간 복잡도 : O(N)
- LinkedList 대신 트리를 이용하면 성능을 개선시킬 수 있다.
- JDK 1.8의 경우 index에 노드가 8개 이하인 경우에는 LinkedList를 사용하고 8개를 넘어갈 경우에는 트리 구조로 데이터 저장 구조를 바꾸도록 설계되어 있다.

## 재해시와 동적해싱

- 재해시(Rehash) : 해싱테이블에 비어 있는 원소가 적으면 해시성능이 급격히 저하되는 현상이 발생, 이러한 경우 재해시를 통해 해시테이블을 확장시키고 새로운 해시함수를 사용하여 모든 키들을 새로운 해시테이블에 다시 저장함
- 동적해싱(Dynamic Hashing) : 재해싱을 수행하지 않고 동적으로 해시테이블의 크기를 조절
  - 해시 버킷 동적 확장(Resize)

## HashTable ve HashMap

- HashMap : Map 인터페이스를 구현하기 위해 HashTable을 사용한 클래스로 key와 value에 Null이 허용된다. 동기화를 지원하지 않는다.
- HashTable : HashMap보다 속도는 느리지만, 동기화를 지원하며 key와 value에 null이 허용되지 않는다.

# 참고

책 <자바와 함께하는 자료구조의 이해>, 양성봉 저, 생능출판.

https://d2.naver.com/helloworld/831311

https://ratsgo.github.io/data%20structure&algorithm/2017/10/25/hash/

https://github.com/WooVictory/Ready-For-Tech-Interview/blob/master/Data%20Structure/%5BData%20Structure%5D%20Hash(%ED%95%B4%EC%8B%9C).md
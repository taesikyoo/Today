# 07 Graph

# 1. 그래프

## 그래프 용어

- 그래프(Graph) = **정점**(Vertex)과 **간선**(Edge)의 집합
  - 하나의 간선은 두 개의 정점을 연결함
  - 그래프 G = (V, E)일 때 V는 정점의 집합이고, E는 간선의 집합
- **방향그래프**(Directed Graph) : 간선에 방향 O
- **무방향그래프**(Undirected Graph) : 간선에 방향 X
  - (a, b) : 정점 a와 b를 연결하는 간선
  - <a, b> : 정점 a와 b를 연결하는 방향이 있는 간선
- **차수**(Degree) : 해당 정점에 인접한 정점의 수
  - 방향그래프에서는 진입차수(In-degree)와 진출차수(Out-degree)로 구분
- **경로**(Path) : 시작 정점 u부터 도착점 v까지의 정점들을 나열하여 표현
  - 단순경로(Simple Path) : 경로 상의 정점들이 모두 다른 경로(중복X)
  - 사이클(Cycle) : 시작 정점과 도착점이 동일한 단순경로
- 연결성분(Connected Component) : 그래프에서 정점들이 서로 연결되어 있는 부분
- 가중치 그래프(Weighted Graph) : 간선에 가중치가 부여된 그래프
- 부분 그래프(Subgraph) : 주어진 그래프의 정점과 간선의 일부분(부분집합)으로 이루어진 그래프
- 트리(Tree) : 방향성이 있고 사이클이 없는 그래프 (DAG, Directed Acyclic Graph)
- 신장트리(Spanning Tree) : 주어진 그래프가 하나의 연결성분으로 구성되어 있을 때, 그래프의 모든 정점들을 싸이클 없이 연결하는 부분그래프

### 그래프와 트리의 차이

<img src="https://gmlwjd9405.github.io/images/data-structure-graph/graph-vs-tree.png" alt="img" style="zoom:80%;" />

## 그래프 자료구조

### 인접행렬 (Adjacency Matrix)

- n개의 정점을 가진 그래프의 인접행렬은 2차원 NxN 배열로 저장
- 배열이 a라면, 정점들을 0, 1, ,2 ... , N-1로 하여, 정점 i와 j 사이에 간선이 없으면 a[i] [j]  = 0 으로, 간선이 있으면 1로 표현
- 가중치 그래프인 경우 1 대신 가중치를 저장

###  인접리스트 (Adjacency List)

- 각 정점마다 한 개의 연결리스트를 이용하여 인접한 각 정점을 노드에 저장

  

- 희소그래프(Sparse Graph) : 정점의 평균 차수가 작음, 실세계의 대부분 그래프, 그래프의 최대 간선 수인 N(N-1)/2보다 적은 간선의 수를 가짐 => 인접리스트가 적합
- 조밀그래프(Dense Graph) : 간선의 수가 최대 간선 수에 근접한 그래프 => 인접행렬이 적합

# 2. 그래프 탐색

### 깊이 우선 탐색 (DFS, Depth First Search)

- DFS는 임의의 정점에서 시작하여 이웃하는 하나의 정점을 방문하고, 방금 방문한 정점의 이웃 정점을 방문하며, 이웃하는 정점들을 모두 방문한 경우에는 이전 정점으로 되돌아가서 탐색을 수행하는 방식으로 진행된다.
- 핵심 아이디어 : 실타래를 가지고 미로에서 출구를 찾기
- 그래프가 하나의 연결성분으로 되어 있을 때 DFS를 수행하며 실선으로 만들어지는 트리를 깊이우선 신장트리(Depth First Spanning Tree)라고 한다.
- 수행시간 : 정점의 수가 N이고, 간선의 수가 M일 때, O(N+M)이다. 각 정점을 한 번씩 방문하며, 각 간선을 한 번씩만 사용하여 탐색하기 때문

### 너비 우선 탐색 (BFS, Breadth First Search)

- BFS는 임의의 정점 s에서 시작하여 s의 모든 이웃하는 정점들을 방문하고, 방문한 정점들의 이웃 정점들을 모두 방문하는 방식으로 그래프의 모든 정점을 방문한다. DFS는 이진트리에서의 레벨순회와 유사하다.
- 핵심 아이디어 : 연못에 돌을 던져서 만들어지는 동심원의 물결이 퍼져나가는 것 같이 정점들을 방문
- 이진트리의 레벨순회에서처럼 큐 자료구조를 사용한다.
- BFS 로 구한 경로는 최단 경로이다.
- 그래프가 하나의 연결성분으로 되어 있을 때 BFS를 수행하며 실선으로 만들어지는 트리를 너비우선 신장트리(Breadth First Spanning Tree)라고 한다.
- 수행시간 : O(N+M),  각 정점을 한 번씩 방문하며, 각 간선을 한 번씩만 사용하여 탐색하기 때문

| 응용                               | DFS  | BFS  |
| ---------------------------------- | ---- | ---- |
| 신장트리, 연결성분, 경로, 사이클   | v    | v    |
| 최소 간선을 사용하는 경로          |      | v    |
| 위상정렬, 이중연결성분, 강연결성분 | v    |      |

# 3. 기본적인 그래프 알고리즘

### 위상정렬 (Topological Sort)

- 위상정렬이란 사이클이 없는 방향그래프(DAG, Directed Acyclic Graph)에서 정점들을 선형순서(즉, 정점들을 일렬)로 나열하는 것
- 단, 위상정렬 결과는 그래프의 각 간선 <u, v>에 대해 u가 v보다 반드시 앞서 나열되어야 한다.
- 즉, 그래프의 각 정점에 대해 순서를 부여하는 것을 위상정렬이라고 한다.
- 주어진 그래프에 따라 여러 개의 위상정렬이 존재할 수도 있다.
- 일반적으로 작업들 사이에 의존관계가 존재할 때 수행 가능한 작업 순서를 도식화하는 데 위상정렬을 사용

# 4. 최소신장트리

- 하나의 연결성분으로 이루어진 무방향 가중치그래프에서 간선의 가중치의 합이 최소인 신장트리를 최소신장트리(Minimum Spanning Tree, MST)라고 한다. 
- 최소신장트리를 찾는 대표적인 알고리즘은 Kruskal, Prim, Sollin 알고리즘이며, 이 알고리즘들은 모두 그리디 알고리즘이다.

### Kruskal 알고리즘

- Kruskal 알고리즘은 간선들을 가중치가 감소하지 않는 순서로 정렬한 후, 가장 가중치가 작은 간선을 트리에 추가하여 사이클을 만들지 않으면 트리 간선으로 선택하고, 사이클을 만들면 버리는 일을 반복하여 N-1개의 간선이 선택되었을 때 알고리즘을 종료한다. (여기서 N은 그래프 정점의 수)

- Kruskal 알고리즘이 그리디 알고리즘인 이유는 남아있는 (정렬된) 간선들 중에서 항상 '욕심내어' 가중치가 가장 작은 간선을 가져오기 때문이다.

- Kruskal의 MST 알고리즘 (최소신장트리 T를 리턴하며, T의 초기값은 empty)

  ``` 
  [1] 가중치가 감소하지 않는 순서로 정렬된 간선 리스트 L을 만든다.
  [2] while (트리의 간선 수 < N-1)
  [3] 	L에서 가장 작은 가중치를 가진 간선 e를 가져오고, e를 L에서 제거한다.
  [4]		if (간선 e가 T에 추가하여 사이클을 만들지 않으면)
  [5]     	간선 e를 T에 추가한다.
  ```

### Prim 알고리즘

- Prim 알고리즘은 임의의 시작정점에서 가장 가까운 정점을 추가하여 간선이 하나의 트리를 만들고, 만들어진 트리에 인접한 가장 가까운 정점을 하나씩 추가하여 최소신장트리를 만든다.

- 초기에 트리 T는 임의의 정점 s만을 가지며, 트리에 속하지 않은 각 정점과 T의 정점(들)에 인접한 간선들 중에서 가장 작은 가중치를 가진 간선의 끝점을 찾기 위해 배열 D를 사용한다.

  ```
  [1] 배열 D를 ∞로 초기화한다. 단, 임의의 시작정점 s의 D[s] = 0으로 초기화한다.
  [2] while (T의 정점 수 < N)
  [3] 	T에 속하지 않은 각 정점 i에 대해 D[i]가 최소인 정점 minVertex를 찾아 T에 추가한다.
  [4]		for (T에 속하지 않은 각 정점 w에 대해서)
  [5]			if (간선 (minVertex, w)의 가중치 < D[w])
  [6]				D[w] = 간선 (minVertex, w)의 가중치
  ```

  

# 5. 최단경로 알고리즘

### Dijkstra 알고리즘

- Prim의 MST 알고리즘과 매우 유사하다. 다른 점은 두 가지

  - Dijkstra 알고리즘은 출발점이 주어지지만 Prim 알고리즘에서는 출발점이 주어지지 않는다.
  - Prim 알고리즘에서는 배열 D의 원소에 간선의 가중치가 저장되지만, Dijkstra 알고리즘에서는 D의 원소에 출발점으로부터 각 정점까지의 경로의 길이가 저장된다.

- 입력그래프는 양수의 가중치를 가진 그래프로서 하나의 연결성분으로 구성되어 있고, s는 출발점일 때

  ```
  [1] 배열 D를 ∞로 초기화한다. 단, D[s] = 0이다.
  [2] for (k = 0; k < N; k++)
  [3] 	방문 안된 각 정점 i에 대해 D[i]가 최소인 정점 minVertex를 찾고, 방문한다.
  [4]		for (minVertex에 인접한 각 정점 w에 대해서)
  [5]			if (w가 방문 안된 정점이면)
  [6]				if (D[minVertex] +간선 (minVertex, w)의 가중치 < D[w])
  [7]				D[w] = D[minVertex] +간선 (minVertex, w)의 가중치 // 간선완화
  [8]				previous[w] = minVertex
  ```

- 핵심 아이디어 : 그리디하게 정점을 선택하여 방문하고, 선택한 정점의 방문되지 않은 인접한 정점들에 대한 간선완화를 수행한다. 한번 방문된 정점의 D 원소 값은 변하지 않는다.

# 참고

책 <자바와 함께하는 자료구조의 이해>, 양성봉 저, 생능출판.

https://gmlwjd9405.github.io/2018/08/13/data-structure-graph.html

https://github.com/JaeYeopHan/Interview_Question_for_Beginner/blob/master/DataStructure/README.md#graph